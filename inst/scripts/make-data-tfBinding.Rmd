---
title: "TF Binding Info"
author: "Xiaosai Yao"
date: 2022-10-06
output:
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

#### 1. Data download
We download public ChIP-seq peak calls from ChIP-Atlas and ENCODE

#### 1.1. ChIP-Atlas

ChIP-seq binding sites were downloaded from [ChIP-Atlas](https://github.com/inutano/chip-atlas/wiki)

```{r}
# metatdata 
# download fileList.tab from https://dbarchive.biosciencedbc.jp/kyushu-u/metadata/fileList.tab

dir <- "chipAtlas/"
fileLIST <- read.delim(paste0(dir, "metadata/fileList.tab"), header = FALSE)


for (genome in c("hg38", "mm10")){
    
    TFLIST <- fileLIST[which(fileLIST[,3] == "TFs and others" &
                                 fileLIST[,2] == genome &
                                 fileLIST[,4] != "-" &
                                 fileLIST[,5] == "All cell types" &
                                 fileLIST[,7] == "05"),]
    
    download.files <- paste0("wget http://dbarchive.biosciencedbc.jp/kyushu-u/", 
                             genome,"/assembled/", TFLIST$V1, ".bed")
    write.table(x = download.files,
                file = paste0(dir, genome, ".sh"),
                quote = FALSE,
                col.names = FALSE,
                row.names = FALSE)
    
    write.table(TFLIST,
                file = paste0(dir, genome,".metadata.txt"),
                quote = FALSE,
                col.names = FALSE,
                row.names = FALSE,
                sep = "\t")
    
}

```

#### 1.2. ENCODE

Transcription factor ChIP-seq peaks were downloaded from [ENCODE data portal](https://www.encodeproject.org/)


#### 2. Merge peaks

Merge peaks of the same TFs into the same bed files.

#### 2.1. ChIP-Atlas

```{r ChIP-Atlas}

library(GenomicRanges)
library(rtracklayer)

##################### chipatlas_bedfiles_merge #####################
## Takes in a list of bed files and an accompanying legend that shows 
## which BED files correspond to  a specific TF
## Outputs a directory of merged bed files

dir <- 'chipAtlas/'
outdir <- 'chipatlas/data/chipatlas'



genomes <- c("mm10","hg38")
chr_order <- list()
chr_order[["mm10"]] <- c(paste0("chr",1:19),"chrX","chrY","chrM")
chr_order[["hg38"]] <- c(paste0("chr",1:22),"chrX","chrY","chrM")

for (genome in genomes){
  # Get directories of all bed files and make a list of the path of all bed files
  list_beds <- list.files(paste0(dir, genome, '_1e5'),
                          pattern = "*.bed")

  # Read the metatdata file

  metadata <- read.delim(paste0(dir, genome, ".metadata.txt"), header=FALSE)
  metadata$filename <- paste0(dir, genome, "_1e5/", metadata$V1,".bed")
  colnames(metadata)[4] <- "TF"

  ## specify sorting order for chromosomes
  chr_order_genome <- chr_order[[genome]]

  ### get list of TFs represented in BED files
  TF.list <- unique(metadata$TF)

  for (i in seq_along(TF.list)) {

    print(TF.list[i])

    # get bed files associated with TF
    TF.files <- metadata[which(metadata$TF == TF.list[i]), "filename"]

    # merge bed files and sort by chromosome and starting coordinate

    merged_bed <- read.delim(TF.files, skip = 1, header = FALSE)
    merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
    merged_bed <- na.omit(merged_bed)
    merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

    ## convert to granges object and merge overlapping ranges
    gr <- makeGRangesFromDataFrame(merged_bed,
                                   seqnames.field = "V1",
                                   start.field = "V2",
                                   end.field = "V3")
    gr <- reduce(gr, drop.empty.ranges = TRUE)

    # write new bed file to directory
    export.bed(gr, con = paste0(outdir,"/", genome, "/", TF.list[i],".bed"))
  }

}
```

#### 2.2. ENCODE

Filter and merge ENCODE peaks

```{r ENCODE}
############### filter peaks ####################
## Takes in bed files and filters the peaks 
## in each file based on the enrichment score.
## Low Enrichment peaks are filtered out.

dir = 'encode/'
outdir = 'chipatlas/data/encode/'
for (genome in c("mm10", "hg38")){

    # Make a list of all the bed files
    list_beds <- list.files(paste0(dir, genome, "/raw"), pattern = "*.bed.gz")

    #filter each bed file to have p value score > 4
    for (i in seq_along(list_beds)) {

        print(list_beds[i])

        curr_bed <- read.table(paste0(dir, genome, "/raw/", list_beds[i]))

        post_QC_bed <- curr_bed[curr_bed$V7 >=5,] #Q values

        if (nrow(post_QC_bed) >100){
            write.table(post_QC_bed,
                        paste0('/gstore/scratch/u/yaox19/encode/', 
                               genome, "/filtered/", list_beds[i]),
                        row.names = F, col.names = F, quote = F, sep="\t")
        }

    }
}




##################### ENCODE_bedfiles_merge #####################
## Takes in a list of bed files and an accompanying legend that shows 
## which BED files correspond to  a specific TF
## Outputs a directory of merged bed files



chr_order <- list()
chr_order[["mm10"]] <- c(paste0("chr",1:19),"chrX","chrY","chrM")
chr_order[["hg38"]] <- c(paste0("chr",1:22),"chrX","chrY","chrM")

replacement <- list(mm10 = "-mouse", hg38 = "-human")

for (genome in c("hg38","mm10")){

    # read metadata
    list_beds <- list.files(paste0(dir, genome, "/raw"), pattern = "*.bed.gz")
    metadata <- read.delim(paste0(dir, genome, "/raw/metadata.tsv"))
    metadata <- metadata[, c("File.accession", "Experiment.target")]
    metadata$"Experiment.target" <-  gsub(replacement[[genome]],"", metadata$"Experiment.target")

    # capitalize the first alphabet for mouse genes
    if (genome == "mm10"){
        metadata$"Experiment.target" <- stringr::str_to_title(metadata$"Experiment.target")
    }

    metadata$"File.accession" <- trimws( metadata$"File.accession")
    metadata$"File.accession" <- paste0(dir, genome, "/filtered/",
                                        metadata$"File.accession",".bed.gz")
    colnames(metadata) <- c("filename","TF")

    # remove files that do not exist
    metadata <- metadata[which(file.exists(metadata$filename)),]

    # specify sorting order for chromosomes
    chr_order_genome <- chr_order[[genome]]

    # get list of TFs represented in BED files
    TF.list <- unique(metadata$TF)

    for (i in seq_along(TF.list)) {

        print(TF.list[i])

        # get bed files associated with TF
        TF.files <- metadata[which(metadata$TF == TF.list[i]), "filename"]

        # merge bed files and sort by chromosome and starting coordinate

        merged_bed <- lapply(TF.files, function(file) read.delim(file, skip = 0, header = FALSE))
        merged_bed <- do.call('rbind', merged_bed)
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order[[genome]])
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        # convert to granges object and merge overlapping ranges
        gr <- makeGRangesFromDataFrame(merged_bed,
                                       seqnames.field = "V1",
                                       start.field = "V2",
                                       end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        # write new bed file to directory
        export.bed(gr, con=paste0(outdir, genome, "/", TF.list[i],".bed"))
    }




}
```

#### 2.3. Merge both ENCODE and ChIP-Atlas

```{r ENCODE and ChIP-seq}

dir <- "chipatlas/data/"

chr_order <- list()
chr_order[["mm10"]] <- c(paste0("chr",1:19),"chrX","chrY","chrM")
chr_order[["hg38"]] <- c(paste0("chr",1:22),"chrX","chrY","chrM")


for (genome in c("mm10", "hg38")){

    # specify sorting order for chromosomes
    chr_order_genome <- chr_order[[genome]]

    ########### merge with chipatlas bed files
    chipatlas.files <- list.files(paste0(dir, "chipatlas/", genome),pattern = "*.bed")
    encode.files <- list.files(paste0(dir, "encode/", genome),pattern = "*.bed")
    shared.TFs <- intersect(chipatlas.files, encode.files)
    chipatlas.TFs <- setdiff(chipatlas.files, encode.files)
    encode.TFs <- setdiff(encode.files, chipatlas.files)

    #### shared.TFs
    for (i in seq_along(shared.TFs)) {

        print(shared.TFs[i])

        chipatlas <- read.table(paste0(dir, "chipatlas/", genome, "/", shared.TFs[i]), sep = "\t")
        encode <- read.table(paste0(dir, "encode/", genome, "/", shared.TFs[i]), sep = "\t")

        merged_bed <- rbind(chipatlas[,1:3], encode[,1:3])
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        gr <- makeGRangesFromDataFrame(merged_bed,seqnames.field = "V1",
                                       start.field = "V2",end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        export.bed(gr, con=paste0(dir, "chipatlas_encode_merged/", genome, "/", shared.TFs[i]))

    }

    ##### chipatlas
    for (i in seq_along(chipatlas.TFs)) {

        print(chipatlas.TFs[i])

        chipatlas <- read.table(paste0(dir, "chipatlas/", genome, "/", chipatlas.TFs[i]), sep = "\t")

        merged_bed <- chipatlas[,1:3]
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        gr <- makeGRangesFromDataFrame(merged_bed,seqnames.field = "V1",
                                       start.field = "V2",end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        export.bed(gr, con=paste0(dir, "chipatlas_encode_merged/", genome, "/", chipatlas.TFs[i]))

    }

    ##### encode
    for (i in seq_along(length(encode.TFs))) {

        print(encode.TFs[i])

        encode <- read.table(paste0(dir, "encode/", genome, "/", encode.TFs[i]),sep = "\t")

        merged_bed <- encode[,1:3]
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        gr <- makeGRangesFromDataFrame(merged_bed,seqnames.field = "V1",
                                       start.field = "V2",end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        export.bed(gr, con=paste0(dir, "chipatlas_encode_merged/", genome, "/", encode.TFs[i]))

    }
}
```

#### 3. Liftover

Perform liftover from hg38 to hg19 for the ChIP-seq binding sites

```{r liftover, eval = FALSE}
# chain downloaded from https://hgdownload.soe.ucsc.edu/goldenPath/hg38/liftOver/hg38ToHg19.over.chain.gz
# need to reformat chain file from space to tab
# sed -r 's/^([0-9]+) ([0-9]+) ([0-9]+)$/\1\t\2\t\3/' hg38ToHg19.over.chain > hg38_to_hg19_tabs.chain

ch <- rtracklayer::import.chain(
    con = "chipatlas/data/hg38_to_hg19_tabs.chain")

# install liftover
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("liftOver")
library(liftOver)

grl_hg19 <- liftOver(grl, ch)
saveRDS(grl_hg19, file = "hg19_motif_bed_granges.rds")
```

#### 4. Session information

```{r}
sessionInfo()
```
