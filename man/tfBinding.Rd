% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tfBinding.R
\name{tfBinding}
\alias{tfBinding}
\title{TF Binding Info}
\format{
\code{GRangeList} object containing binding site information of transcription factor
ChIP-seq merged from ChIPAtlas database and ENCODE.
Contains the following experiments:
\itemize{
\item{\strong{hg38}: GRangesList object of length 1558}
\item{\strong{hg19}: GRangesList object of length 1558}
\item{\strong{mm10}: GRangesList object of length 768}
}
}
\usage{
tfBinding(genome = c("hg38", "hg19", "mm10"), metadata = FALSE)
}
\arguments{
\item{genome}{String indicating the genomic build}

\item{metadata}{logical flag specifying whether to return data or metadata only}
}
\value{
Granges List of TF binding sites
}
\description{
Combined transcription factor ChIP-seq data from ChIP-Atlas and ENCODE.
This is a special data set that stores transcription factor binding sites for human and
mouse genomic builds, which can be used with multiome data to compute epiregulons.
}
\section{Data storage and access}{

Each genomic build is a separate \code{GRangesList} object. Each \code{GRangesList}
is split into individual \code{GRanges} objects, converted into data frames,
and then stored in a single hdf5 file. Data can be accessed with a special
function that extracts the requested genomic build and converts the data frame back to
\code{GRangesList}.
}

\section{Data preparation}{

\subsection{1. Data download}{

We download public ChIP-seq peak calls from ChIP-Atlas and ENCODE
}

\subsection{1.1. ChIP-Atlas}{

ChIP-seq binding sites were downloaded from \href{https://github.com/inutano/chip-atlas/wiki}{ChIP-Atlas}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# metatdata 
# download fileList.tab from https://dbarchive.biosciencedbc.jp/kyushu-u/metadata/fileList.tab

dir <- "chipAtlas/"
fileLIST <- read.delim(paste0(dir, "metadata/fileList.tab"), header = FALSE)


for (genome in c("hg38", "mm10"))\{
    
    TFLIST <- fileLIST[which(fileLIST[,3] == "TFs and others" &
                                 fileLIST[,2] == genome &
                                 fileLIST[,4] != "-" &
                                 fileLIST[,5] == "All cell types" &
                                 fileLIST[,7] == "05"),]
    
    download.files <- paste0("wget http://dbarchive.biosciencedbc.jp/kyushu-u/", 
                             genome,"/assembled/", TFLIST$V1, ".bed")
    write.table(x = download.files,
                file = paste0(dir, genome, ".sh"),
                quote = FALSE,
                col.names = FALSE,
                row.names = FALSE)
    
    write.table(TFLIST,
                file = paste0(dir, genome,".metadata.txt"),
                quote = FALSE,
                col.names = FALSE,
                row.names = FALSE,
                sep = "\\t")
    
\}

}\if{html}{\out{</div>}}
}

\subsection{1.2. ENCODE}{

Transcription factor ChIP-seq peaks were downloaded from \href{https://www.encodeproject.org/}{ENCODE data portal}
}

\subsection{2. Merge peaks}{

Merge peaks of the same TFs into the same bed files.
}

\subsection{2.1. ChIP-Atlas}{

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
library(GenomicRanges)
library(rtracklayer)

##################### chipatlas_bedfiles_merge #####################
## Takes in a list of bed files and an accompanying legend that shows 
## which BED files correspond to  a specific TF
## Outputs a directory of merged bed files

dir <- 'chipAtlas/'
outdir <- 'chipatlas/data/chipatlas'



genomes <- c("mm10","hg38")
chr_order <- list()
chr_order[["mm10"]] <- c(paste0("chr",1:19),"chrX","chrY","chrM")
chr_order[["hg38"]] <- c(paste0("chr",1:22),"chrX","chrY","chrM")

for (genome in genomes)\{
  # Get directories of all bed files and make a list of the path of all bed files
  list_beds <- list.files(paste0(dir, genome, '_1e5'),
                          pattern = "*.bed")

  # Read the metatdata file

  metadata <- read.delim(paste0(dir, genome, ".metadata.txt"), header=FALSE)
  metadata$filename <- paste0(dir, genome, "_1e5/", metadata$V1,".bed")
  colnames(metadata)[4] <- "TF"

  ## specify sorting order for chromosomes
  chr_order_genome <- chr_order[[genome]]

  ### get list of TFs represented in BED files
  TF.list <- unique(metadata$TF)

  for (i in seq_along(TF.list)) \{

    print(TF.list[i])

    # get bed files associated with TF
    TF.files <- metadata[which(metadata$TF == TF.list[i]), "filename"]

    # merge bed files and sort by chromosome and starting coordinate

    merged_bed <- read.delim(TF.files, skip = 1, header = FALSE)
    merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
    merged_bed <- na.omit(merged_bed)
    merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

    ## convert to granges object and merge overlapping ranges
    gr <- makeGRangesFromDataFrame(merged_bed,
                                   seqnames.field = "V1",
                                   start.field = "V2",
                                   end.field = "V3")
    gr <- reduce(gr, drop.empty.ranges = TRUE)

    # write new bed file to directory
    export.bed(gr, con = paste0(outdir,"/", genome, "/", TF.list[i],".bed"))
  \}

\}
}\if{html}{\out{</div>}}
}

\subsection{2.2. ENCODE}{

Filter and merge ENCODE peaks

\if{html}{\out{<div class="sourceCode r">}}\preformatted{############### filter peaks ####################
## Takes in bed files and filters the peaks 
## in each file based on the enrichment score.
## Low Enrichment peaks are filtered out.

dir = 'encode/'
outdir = 'chipatlas/data/encode/'
for (genome in c("mm10", "hg38"))\{

    # Make a list of all the bed files
    list_beds <- list.files(paste0(dir, genome, "/raw"), pattern = "*.bed.gz")

    #filter each bed file to have p value score > 4
    for (i in seq_along(list_beds)) \{

        print(list_beds[i])

        curr_bed <- read.table(paste0(dir, genome, "/raw/", list_beds[i]))

        post_QC_bed <- curr_bed[curr_bed$V7 >=5,] #Q values

        if (nrow(post_QC_bed) >100)\{
            write.table(post_QC_bed,
                        paste0('/gstore/scratch/u/yaox19/encode/', 
                               genome, "/filtered/", list_beds[i]),
                        row.names = F, col.names = F, quote = F, sep="\\t")
        \}

    \}
\}




##################### ENCODE_bedfiles_merge #####################
## Takes in a list of bed files and an accompanying legend that shows 
## which BED files correspond to  a specific TF
## Outputs a directory of merged bed files



chr_order <- list()
chr_order[["mm10"]] <- c(paste0("chr",1:19),"chrX","chrY","chrM")
chr_order[["hg38"]] <- c(paste0("chr",1:22),"chrX","chrY","chrM")

replacement <- list(mm10 = "-mouse", hg38 = "-human")

for (genome in c("hg38","mm10"))\{

    # read metadata
    list_beds <- list.files(paste0(dir, genome, "/raw"), pattern = "*.bed.gz")
    metadata <- read.delim(paste0(dir, genome, "/raw/metadata.tsv"))
    metadata <- metadata[, c("File.accession", "Experiment.target")]
    metadata$"Experiment.target" <-  gsub(replacement[[genome]],"", metadata$"Experiment.target")

    # capitalize the first alphabet for mouse genes
    if (genome == "mm10")\{
        metadata$"Experiment.target" <- stringr::str_to_title(metadata$"Experiment.target")
    \}

    metadata$"File.accession" <- trimws( metadata$"File.accession")
    metadata$"File.accession" <- paste0(dir, genome, "/filtered/",
                                        metadata$"File.accession",".bed.gz")
    colnames(metadata) <- c("filename","TF")

    # remove files that do not exist
    metadata <- metadata[which(file.exists(metadata$filename)),]

    # specify sorting order for chromosomes
    chr_order_genome <- chr_order[[genome]]

    # get list of TFs represented in BED files
    TF.list <- unique(metadata$TF)

    for (i in seq_along(TF.list)) \{

        print(TF.list[i])

        # get bed files associated with TF
        TF.files <- metadata[which(metadata$TF == TF.list[i]), "filename"]

        # merge bed files and sort by chromosome and starting coordinate

        merged_bed <- lapply(TF.files, function(file) read.delim(file, skip = 0, header = FALSE))
        merged_bed <- do.call('rbind', merged_bed)
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order[[genome]])
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        # convert to granges object and merge overlapping ranges
        gr <- makeGRangesFromDataFrame(merged_bed,
                                       seqnames.field = "V1",
                                       start.field = "V2",
                                       end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        # write new bed file to directory
        export.bed(gr, con=paste0(outdir, genome, "/", TF.list[i],".bed"))
    \}




\}
}\if{html}{\out{</div>}}
}

\subsection{2.3. Merge both ENCODE and ChIP-Atlas}{

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
dir <- "chipatlas/data/"

chr_order <- list()
chr_order[["mm10"]] <- c(paste0("chr",1:19),"chrX","chrY","chrM")
chr_order[["hg38"]] <- c(paste0("chr",1:22),"chrX","chrY","chrM")


for (genome in c("mm10", "hg38"))\{

    # specify sorting order for chromosomes
    chr_order_genome <- chr_order[[genome]]

    ########### merge with chipatlas bed files
    chipatlas.files <- list.files(paste0(dir, "chipatlas/", genome),pattern = "*.bed")
    encode.files <- list.files(paste0(dir, "encode/", genome),pattern = "*.bed")
    shared.TFs <- intersect(chipatlas.files, encode.files)
    chipatlas.TFs <- setdiff(chipatlas.files, encode.files)
    encode.TFs <- setdiff(encode.files, chipatlas.files)

    #### shared.TFs
    for (i in seq_along(shared.TFs)) \{

        print(shared.TFs[i])

        chipatlas <- read.table(paste0(dir, "chipatlas/", genome, "/", shared.TFs[i]), sep = "\\t")
        encode <- read.table(paste0(dir, "encode/", genome, "/", shared.TFs[i]), sep = "\\t")

        merged_bed <- rbind(chipatlas[,1:3], encode[,1:3])
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        gr <- makeGRangesFromDataFrame(merged_bed,seqnames.field = "V1",
                                       start.field = "V2",end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        export.bed(gr, con=paste0(dir, "chipatlas_encode_merged/", genome, "/", shared.TFs[i]))

    \}

    ##### chipatlas
    for (i in seq_along(chipatlas.TFs)) \{

        print(chipatlas.TFs[i])

        chipatlas <- read.table(paste0(dir, "chipatlas/", genome, "/", chipatlas.TFs[i]), sep = "\\t")

        merged_bed <- chipatlas[,1:3]
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        gr <- makeGRangesFromDataFrame(merged_bed,seqnames.field = "V1",
                                       start.field = "V2",end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        export.bed(gr, con=paste0(dir, "chipatlas_encode_merged/", genome, "/", chipatlas.TFs[i]))

    \}

    ##### encode
    for (i in seq_along(length(encode.TFs))) \{

        print(encode.TFs[i])

        encode <- read.table(paste0(dir, "encode/", genome, "/", encode.TFs[i]),sep = "\\t")

        merged_bed <- encode[,1:3]
        merged_bed$V1 <- factor(merged_bed$V1, levels = chr_order_genome)
        merged_bed <- na.omit(merged_bed)
        merged_bed <- merged_bed[order(merged_bed$V1, merged_bed$V2),]

        gr <- makeGRangesFromDataFrame(merged_bed,seqnames.field = "V1",
                                       start.field = "V2",end.field = "V3")
        gr <- reduce(gr, drop.empty.ranges = TRUE)

        export.bed(gr, con=paste0(dir, "chipatlas_encode_merged/", genome, "/", encode.TFs[i]))

    \}
\}
}\if{html}{\out{</div>}}
}

\subsection{3. Liftover}{

Perform liftover from hg38 to hg19 for the ChIP-seq binding sites

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# chain downloaded from https://hgdownload.soe.ucsc.edu/goldenPath/hg38/liftOver/hg38ToHg19.over.chain.gz
# need to reformat chain file from space to tab
# sed -r 's/^([0-9]+) ([0-9]+) ([0-9]+)$/\\1\\t\\2\\t\\3/' hg38ToHg19.over.chain > hg38_to_hg19_tabs.chain

ch <- rtracklayer::import.chain(
    con = "chipatlas/data/hg38_to_hg19_tabs.chain")

# install liftover
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("liftOver")
library(liftOver)

grl_hg19 <- liftOver(grl, ch)
saveRDS(grl_hg19, file = "hg19_motif_bed_granges.rds")
}\if{html}{\out{</div>}}
}

\subsection{4. Session information}{

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sessionInfo()
}\if{html}{\out{</div>}}
}
}

\examples{
tfBinding("hg38")

}
\references{
ChIP-Atlas 2021 update: a data-mining suite for exploring epigenomic landscapes by
fully integrating ChIP-seq, ATAC-seq and Bisulfite-seq data.
Zou Z, Ohta T, Miura F, Oki S.
\emph{Nucleic Acids Research. Oxford University Press (OUP);} 2022.
\href{http://dx.doi.org/10.1093/nar/gkac199}{doi:10.1093/nar/gkac199}

ChIP‐Atlas: a data‐mining suite powered by full integration of public ChIP‐seq data.
Oki S, Ohta T, Shioi G, Hatanaka H, Ogasawara O, Okuda Y, Kawaji H, Nakaki R, Sese J, Meno C.
\emph{EMBO}; Vol. 19, EMBO reports. 2018.
\href{http://dx.doi.org/10.15252/embr.201846255}{doi: 10.15252/embr.201846255}

ENCODE: {https://www.encodeproject.org/}
}
